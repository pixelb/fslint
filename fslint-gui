#!/usr/bin/env python2
# vim:fileencoding=utf-8

# Note both python and vim understand the above encoding declaration

# Note using env above will cause the system to register
# the name (in ps etc.) as "python" rather than fslint-gui
# (because "python" is passed to exec by env).

"""
 FSlint - A utility to find File System lint.
 Copyright © 2000-2014 by Pádraig Brady <P@draigBrady.com>.

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 See the GNU General Public License for more details,
 which is available at www.gnu.org
"""

import types, os, sys, pipes, time, stat, tempfile, errno

import gettext
import locale

try:
    import gtk
except RuntimeError:
    etype, emsg, etb = sys.exc_info()
    sys.stderr.write(str(emsg)+'\n')
    sys.exit(1)

import gtk.glade

time_commands=False #print sub commands timing on status line

def puts(string=""): #print is problematic in python 3
    sys.stdout.write(str(string)+'\n')

BAD_DIRS = ['/lost+found','/dev','/proc','/sys','/tmp',
            '*/.svn','*/CVS', '*/.git', '*/.hg', '*/.bzr',
            '*/node_modules']

liblocation=os.path.dirname(os.path.abspath(sys.argv[0]))
locale_base=liblocation+'/po/locale'
try:
    import fslint
    if sys.argv[0][0] != '/':
        #If relative probably debugging so don't use system files if possible
        if not os.path.exists(liblocation+'/fslint'):
            liblocation = fslint.liblocation
            locale_base = None #sys default
    else:
        liblocation = fslint.liblocation
        locale_base = None #sys default
except:
    pass

class i18n:

    def __init__(self):
        self._init_translations()
        self._init_locale() #after translations in case they reset codeset
        self._init_preferred_encoding()

    def _init_translations(self):
        #gtk2 only understands utf-8 so convert to unicode
        #which will be automatically converted to utf-8 by pygtk
        gettext.install("fslint", locale_base, unicode=1)
        global N_ #translate string but not at point of definition
        def N_(string): return string
        gettext.bindtextdomain("fslint",locale_base)
        gettext.textdomain("fslint")
        #Note gettext does not set libc's domain as
        #libc and Python may have different message catalog
        #formats (e.g. on Solaris). So make explicit calls.
        locale.bindtextdomain("fslint",locale_base)
        locale.textdomain("fslint")

    def _init_locale(self):
        try:
            locale.setlocale(locale.LC_ALL,'')
        except:
            #gtk will print warning for a duff locale
            pass

    def _init_preferred_encoding(self):
        #Note that this encoding name is canonlicalised already
        self.preferred_encoding=locale.getpreferredencoding(do_setlocale=False)
        #filename encoding can be different from default encoding
        filename_encoding = os.environ.get("G_FILENAME_ENCODING")
        if filename_encoding:
            try:
                #Try out the encoding to avoid exceptions later.
                #For example on Suse 11.4 this is actually a list
                #  @locale,UTF-8,$west_europe_legacy_encoding,CP1252
                #which we don't support for the moment.
                "".encode(filename_encoding)
            except:
                 filename_encoding = None
        if filename_encoding:
            filename_encoding=filename_encoding.lower()
            if filename_encoding == "utf8": filename_encoding="utf-8"
            self.filename_encoding=filename_encoding
        else:
            self.filename_encoding=self.preferred_encoding

    class unicode_displayable(unicode):
        """translate non displayable chars to an appropriate representation"""
        translate_table=range(0x2400,0x2420) #control chars
        #Since python 2.2 this will be a new style class as
        #we are subclassing the builtin (immutable) unicode type.
        #Therefore we can make a factory function with the following.
        def __new__(cls,string,exclude):
            if exclude:
                curr_table=cls.translate_table[:] #copy
                for char in exclude:
                    try:
                        curr_table[ord(char)]=ord(char)
                    except:
                        pass #won't be converted anyway
            else:
                curr_table=cls.translate_table
            translated_string=unicode(string).translate(curr_table)
            return unicode.__new__(cls, translated_string)

    def displayable_utf8(self,orig,exclude="",path=False):
        """Convert to utf8, and also convert chars that are not
        easily displayable (control chars currently).
        If orig is not a valid utf8 string,
        then try to convert to utf8 using preferred encoding while
        also replacing undisplayable or invalid characters.
        Exclude contains control chars you don't want to translate."""
        if type(orig) == types.UnicodeType:
            uc=orig
        else:
            try:
                uc=unicode(orig,"utf-8")
            except:
                try:
                    # Note I don't use "replace" here as that
                    # replaces multiple bytes with a FFFD in utf8 locales
                    # This is silly as then you know it's not utf8 so
                    # one should try each character.
                    if path:
                        uc=unicode(orig,self.filename_encoding)
                    else:
                        uc=unicode(orig,self.preferred_encoding)
                except:
                    uc=unicode(orig,"ascii","replace")
                    # Note I don't like the "replacement char" representation
                    # on fedora core 3 at least (bitstream-vera doesn't have it,
                    # and the nimbus fallback looks like a comma).
                    # It's even worse on redhat 9 where there is no
                    # representation at all. Note FreeSans does have a nice
                    # question mark representation, and dejavu also since 1.12.
                    # Alternatively I could: uc=unicode(orig,"latin-1") as that
                    # has a representation for each byte, but it's not general.
        uc=self.unicode_displayable(uc, exclude)
        return uc.encode("utf-8")

    def g_filename_from_utf8(self, string):
        if self.filename_encoding != "utf-8":
            uc=unicode(string,"utf-8")
            string=uc.encode(self.filename_encoding) #can raise exception
        return string

I18N=i18n() #call first so everything is internationalized

import getopt
def Usage():
    puts(_("Usage: %s [OPTION] [PATHS]") % os.path.split(sys.argv[0])[1])
    puts(  "    --version       " + _("display version"))
    puts(  "    --help          " + _("display help"))

try:
    lOpts, lArgs = getopt.getopt(sys.argv[1:], "", ["help","version"])

    if len(lArgs) == 0:
        lArgs = [os.getcwd()]

    if ("--help","") in lOpts:
        Usage()
        sys.exit(None)

    if ("--version","") in lOpts:
        puts("FSlint 2.47")
        sys.exit(None)
except getopt.error as msg:
    puts(msg)
    puts()
    Usage()
    sys.exit(2)

def human_num(num, divisor=1, power=""):
    num=float(num)
    if divisor == 1:
        return locale.format("%.f",num,1)
    elif divisor == 1000:
        powers=[" ","K","M","G","T","P"]
    elif divisor == 1024:
        powers=["  ","Ki","Mi","Gi","Ti","Pi"]
    else:
        raise ValueError("Invalid divisor")
    if not power: power=powers[0]
    while num >= 1000: #4 digits
        num /= divisor
        power=powers[powers.index(power)+1]
    if power.strip():
        num = locale.format("%6.1f",num,1)
    else:
        num = locale.format("%4.f",num,1)+'  '
    return "%s%s" % (num,power)

class pathInfo:
    """Gets path info appropriate for display, i.e.
        (ls_colour, du, size, uid, gid, ls_date, mtime)"""

    def __init__(self, path):
        stat_val = os.lstat(path)

        date = time.ctime(stat_val.st_mtime)
        month_time = date[4:16]
        year = date[-5:]
        timediff = time.time()-stat_val.st_mtime
        if timediff > 15552000: #6months
            date = month_time[0:6] + year
        else:
            date = month_time

        mode = stat_val.st_mode
        if stat.S_ISREG(mode):
            colour = '' #default
            if mode & (stat.S_IXGRP|stat.S_IXUSR|stat.S_IXOTH):
                colour = "#00C000"
        elif stat.S_ISDIR(mode):
            colour = "blue"
        elif stat.S_ISLNK(mode):
            colour = "cyan"
            if not os.path.exists(path):
                colour = "#C00000"
        else:
            colour = "tan"

        self.ls_colour = colour
        self.du = stat_val.st_blocks*512
        self.size = stat_val.st_size
        self.uid = stat_val.st_uid
        self.gid = stat_val.st_gid
        self.ls_date = date
        self.mtime = stat_val.st_mtime
        self.inode = stat_val.st_ino

class GladeWrapper:
    """
    Superclass for glade based applications. Just derive from this
    and your subclass should create methods whose names correspond to
    the signal handlers defined in the glade file. Any other attributes
    in your class will be safely ignored.

    This class will give you the ability to do:
        subclass_instance.GtkWindow.method(...)
        subclass_instance.widget_name...
    """
    def __init__(self, Filename, WindowName):
        #load glade file.
        self.widgets = gtk.glade.XML(Filename, WindowName, gettext.textdomain())
        self.GtkWindow = getattr(self, WindowName)

        instance_attributes = {}
        for attribute in dir(self.__class__):
            instance_attributes[attribute] = getattr(self, attribute)
        self.widgets.signal_autoconnect(instance_attributes)

    def __getattr__(self, attribute): #Called when no attribute in __dict__
        widget = self.widgets.get_widget(attribute)
        if widget is None:
            raise AttributeError("Widget [" + attribute + "] not found")
        self.__dict__[attribute] = widget #add reference to cache
        return widget

# SubProcess Example:
#
#     process = subProcess("your shell command")
#     process.read() #timeout is optional
#     handle(process.outdata, process.errdata)
#     del(process)
import select, signal
class subProcess:
    """Class representing a child process. It's like popen2.Popen3
       but there are three main differences.
       1. This makes the new child process group leader (using setpgrp())
          so that all children can be killed.
       2. The output function (read) is optionally non blocking returning in
          specified timeout if nothing is read, or as close to specified
          timeout as possible if data is read.
       3. The output from both stdout & stderr is read (into outdata and
          errdata). Reading from multiple outputs while not deadlocking
          is not trivial and is often done in a non robust manner."""

    def __init__(self, cmd, bufsize=8192):
        """The parameter 'cmd' is the shell command to execute in a
        sub-process. If the 'bufsize' parameter is specified, it
        specifies the size of the I/O buffers from the child process."""
        self.cleaned=False
        self.BUFSIZ=bufsize
        self.outr, self.outw = os.pipe()
        self.errr, self.errw = os.pipe()
        self.pid = os.fork()
        if self.pid == 0:
            self._child(cmd)
        os.close(self.outw) #parent doesn't write so close
        os.close(self.errw)
        # Note we could use self.stdout=fdopen(self.outr) here
        # to get a higher level file object like popen2.Popen3 uses.
        # This would have the advantages of auto handling the BUFSIZ
        # and closing the files when deleted. However it would mean
        # that it would block waiting for a full BUFSIZ unless we explicitly
        # set the files non blocking, and there would be extra uneeded
        # overhead like EOL conversion. So I think it's handier to use os.read()
        self.outdata = self.errdata = ''
        self._outeof = self._erreof = 0

    def _child(self, cmd):
        # Note exec doesn't reset SIG_IGN -> SIG_DFL
        # and python sets SIGPIPE etc. to SIG_IGN, so reset:
        # http://bugs.python.org/issue1652
        signals = ('SIGPIPE', 'SIGXFZ', 'SIGXFSZ')
        for sig in signals:
            if hasattr(signal, sig):
                signal.signal(getattr(signal, sig), signal.SIG_DFL)

        # Note sh below doesn't setup a seperate group (job control)
        # for non interactive shells (hmm maybe -m option does?)
        os.setpgrp() #seperate group so we can kill it
        os.dup2(self.outw,1) #stdout to write side of pipe
        os.dup2(self.errw,2) #stderr to write side of pipe
        #stdout & stderr connected to pipe, so close all other files
        map(os.close,(self.outr,self.outw,self.errr,self.errw))
        try:
            cmd = ['/bin/sh', '-c', cmd]
            os.execvp(cmd[0], cmd)
        finally: #exit child on error
            os._exit(1)

    def read(self, timeout=None):
        """return 0 when finished
           else return 1 every timeout seconds
           data will be in outdata and errdata"""
        currtime=time.time()
        while 1:
            tocheck=[self.outr]*(not self._outeof)+ \
                    [self.errr]*(not self._erreof)
            ready = select.select(tocheck,[],[],timeout)
            if len(ready[0]) == 0: #no data timeout
                return 1
            else:
                if self.outr in ready[0]:
                    outchunk = os.read(self.outr,self.BUFSIZ)
                    if outchunk == '':
                        self._outeof = 1
                    self.outdata += outchunk
                if self.errr in ready[0]:
                    errchunk = os.read(self.errr,self.BUFSIZ)
                    if errchunk == '':
                        self._erreof = 1
                    self.errdata += errchunk
                if self._outeof and self._erreof:
                    return 0
                elif timeout:
                    if (time.time()-currtime) > timeout:
                        return 1 #may be more data but time to go

    def kill(self):
        os.kill(-self.pid, signal.SIGTERM) #kill whole group

    def pause(self):
        os.kill(-self.pid, signal.SIGSTOP) #pause whole group

    def resume(self):
        os.kill(-self.pid, signal.SIGCONT) #resume whole group

    def cleanup(self):
        """Wait for and return the exit status of the child process."""
        self.cleaned=True
        os.close(self.outr)
        os.close(self.errr)
        pid, sts = os.waitpid(self.pid, 0)
        if pid == self.pid:
            self.sts = sts
        else:
            self.sts = None
        return self.sts

    def __del__(self):
        if not self.cleaned:
            self.cleanup()

# Determine what type of distro we're on.
class distroType:
    def __init__(self):
        types = ("rpm", "dpkg", "pacman")
        for dist in types:
            setattr(self, dist, False)
        if os.path.exists("/etc/redhat-release"):
            self.rpm = True
        elif os.path.exists("/etc/debian_version"):
            self.dpkg = True
        elif os.path.exists("/etc/arch-release"):
            self.pacman = True
        else:
            for dist in types:
                cmd = dist + " --version >/dev/null 2>&1"
                if os.WEXITSTATUS(os.system(cmd)) == 0:
                    setattr(self, dist, True)
                    break
dist_type=distroType()

def human_space_left(where):
    (device, total, used_b, avail, used_p, mount)=\
    os.popen("df -Ph %s | tail -n1" % where).read().split()
    translation_map={"percent":used_p, "disk":mount, "size":avail}
    return _("%(percent)s of %(disk)s is used leaving %(size)sB available") %\
             translation_map

# Avoid using clist.get_selectable() which is O(n)
def get_selectable(row, row_data):
    return row_data[row][0] != '#'

class dlgUserInteraction(GladeWrapper):
    """
    Note input buttons tuple text should not be translated
    so that the stock buttons are used if possible. But the
    translations should be available, so use N_ for input
    buttons tuple text. Note the returned response is not
    translated either. Note also, that if you know a stock
    button is already available, then there's no point in
    translating the passed in string.
    """
    def init(self, app, message, buttons, entry_default,
             again=False, again_val=True):
        for text in buttons:
            try:
                stock_text=getattr(gtk,"STOCK_"+text.upper())
                button = gtk.Button(stock=stock_text)
            except:
                button = gtk.Button(label=_(text))
            button.set_data("text", text)
            button.connect("clicked", self.button_clicked)
            self.GtkWindow.action_area.pack_start(button)
            button.show()
            button.set_flags(gtk.CAN_DEFAULT)
            button.grab_default() #last button is default
        self.app = app
        self.lblmsg.set_text(message)
        self.lblmsg.show()
        self.response=None
        if message.endswith(":"):
            if entry_default:
                self.entry.set_text(entry_default)
            self.entry.show()
            self.input=None
        else:
            self.entry.hide()
        if again:
            self.again=again_val
            if type(again) == types.StringType:
                self.chkAgain.set_label(again)
                self.chkAgain.set_active(again_val)
            #Dialog seems to give focus to first available widget,
            #So undo the focus on the check box
            self.GtkWindow.action_area.get_children()[-1].grab_focus()
            self.chkAgain.show()


    def show(self):
        self.GtkWindow.set_transient_for(self.app.GtkWindow)#center on main win
        self.GtkWindow.show() #Note dialog is initially hidden in glade file
        if self.GtkWindow.modal:
            gtk.main() #synchronous call from parent
        #else: not supported

    #################
    # Signal handlers
    #################

    def quit(self, *args):
        if self.GtkWindow.modal:
            gtk.main_quit()

    def button_clicked(self, button):
        self.response = button.get_data("text")
        if self.entry.flags() & gtk.VISIBLE:
            self.input = self.entry.get_text()
        if self.chkAgain.flags() & gtk.VISIBLE:
            self.again = self.chkAgain.get_active()
        self.GtkWindow.destroy()

class dlgPath(GladeWrapper):

    def init(self, app):
        self.app = app
        self.pwd = self.app.pwd

    def show(self, fileOps=False, filename=""):
        self.canceled = True
        self.fileOps = fileOps
        if self.fileOps:
            # Change to last folder as more likely to want
            # to save results there
            self.GtkWindow.set_action(gtk.FILE_CHOOSER_ACTION_SAVE)
            self.GtkWindow.set_current_folder(self.pwd)
            self.GtkWindow.set_current_name(filename)
        else:
            self.GtkWindow.set_action(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)
            # set_filename doesn't highlight dir after first call
            # so using select_filename for consistency. Also I think
            # select_filename is better than set_current_folder as
            # it allows one to more easily select items at the same level
            self.GtkWindow.select_filename(self.pwd)
        self.GtkWindow.set_transient_for(self.app.GtkWindow)#center on main win
        self.GtkWindow.show()
        if self.GtkWindow.modal:
            gtk.main() #synchronous call from parent
        #else: not supported

    #################
    # Signal handlers
    #################

    def quit(self, *args):
        self.GtkWindow.hide()
        if not self.canceled:
            if self.fileOps:
                self.pwd = self.GtkWindow.get_current_folder()
            else:
                user_path = self.GtkWindow.get_filename()
                if os.path.exists(user_path):
                    self.pwd = user_path
        if self.GtkWindow.modal:
            gtk.main_quit()
        return True #Don't let window be destroyed

    def on_ok_clicked(self, *args):
        file = self.GtkWindow.get_filename()
        if not file:
            # This can happen for the fileOps case, or otherwise
            # if one clicks on the "recently used" group and
            # then clicks Ok without selecting anything.
            return True #Don't let window be destroyed

        if self.fileOps: #creating new item
            if os.path.isdir(file):
                self.GtkWindow.set_current_folder(file)
                return True #Don't let window be destroyed
            if os.path.exists(file):
                if os.path.isfile(file):
                    (response,) = self.app.msgbox(
                      _("Do you want to overwrite?\n") + file,
                      ('Yes', 'No')
                    )
                    if response != "Yes":
                        return
                else:
                    self.app.msgbox(_("You can't overwrite ") + file)
                    return
        self.canceled = False
        self.quit()

class fslint(GladeWrapper):

    class UserAbort(Exception):
        pass

    def __init__(self, Filename, WindowName):
        os.close(0) #don't hang if any sub cmd tries to read from stdin
        os.open("/dev/null", os.O_RDONLY)
        self.pwd=os.path.realpath(os.curdir)
        GladeWrapper.__init__(self, Filename, WindowName)
        self.dlgPath = dlgPath(liblocation+"/fslint.glade", "PathChoose")
        self.dlgPath.init(self)
        self.confirm_delete = True
        self.confirm_delete_group = True
        self.confirm_clean = True
        #Just need to keep this tuple in sync with tabs
        (self.mode_up, self.mode_pkgs, self.mode_nl, self.mode_sn,
         self.mode_tf, self.mode_bl, self.mode_id, self.mode_ed,
         self.mode_ns, self.mode_rs) = range(10)
        self.clists = {
            self.mode_up:self.clist_dups,
            self.mode_pkgs:self.clist_pkgs,
            self.mode_nl:self.clist_nl,
            self.mode_sn:self.clist_sn,
            self.mode_tf:self.clist_tf,
            self.mode_bl:self.clist_bl,
            self.mode_id:self.clist_id,
            self.mode_ed:self.clist_ed,
            self.mode_ns:self.clist_ns,
            self.mode_rs:self.clist_rs
        }
        self.mode_descs = {
            self.mode_up:_("Files with the same content"),
            self.mode_pkgs:_("Installed packages ordered by disk usage"),
            self.mode_nl:_("Problematic filenames"),
            self.mode_sn:_("Possibly conflicting commands or filenames"),
            self.mode_tf:_("Possibly old temporary files"),
            self.mode_bl:_("Problematic symbolic links"),
            self.mode_id:_("Files with missing user IDs"),
            self.mode_ed:_("Directory branches with no files"),
            self.mode_ns:_("Executables still containing debugging info"),
            self.mode_rs:_("Erroneous whitespace in a text file")
        }
        for path in lArgs:
            if os.path.exists(path):
                self.addDirs(self.ok_dirs, os.path.abspath(path))
            else:
                self.ShowErrors(_("Invalid path [") + path + "]")
        for bad_dir in BAD_DIRS:
            self.addDirs(self.bad_dirs, bad_dir)
        self._alloc_mouse_cursors()
        self.mode=0
        self.status.set_text(self.mode_descs[self.mode])
        self.bg_colour=self.vpanes.get_style().bg[gtk.STATE_NORMAL]
        #make readonly GtkEntry and GtkTextView widgets obviously so,
        #by making them the same colour as the surrounding panes
        self.errors.modify_base(gtk.STATE_NORMAL,self.bg_colour)
        self.status.modify_base(gtk.STATE_NORMAL,self.bg_colour)
        self.pkg_info.modify_base(gtk.STATE_NORMAL,self.bg_colour)
        #Other GUI stuff that ideally [lib]glade should support
        self.clist_pkgs.set_column_visibility(2,0)
        self.clist_pkgs.set_column_visibility(3,0)
        self.clist_ns.set_column_justification(2,gtk.JUSTIFY_RIGHT)

    def _alloc_mouse_cursors(self):
        #The following is the cursor used by mozilla and themed by X/distros
        left_ptr_watch = \
        "\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x0c\x00\x00\x00"\
        "\x1c\x00\x00\x00\x3c\x00\x00\x00\x7c\x00\x00\x00\xfc\x00\x00\x00"\
        "\xfc\x01\x00\x00\xfc\x3b\x00\x00\x7c\x38\x00\x00\x6c\x54\x00\x00"\
        "\xc4\xdc\x00\x00\xc0\x44\x00\x00\x80\x39\x00\x00\x80\x39"+"\x00"*66
        try:
            pix = gtk.gdk.bitmap_create_from_data(None, left_ptr_watch, 32, 32)
            color = gtk.gdk.Color()
            self.LEFT_PTR_WATCH=gtk.gdk.Cursor(pix, pix, color, color, 2, 2)
            #Note mask is ignored when doing the hash
        except TypeError:
            #http://bugzilla.gnome.org/show_bug.cgi?id=103616 #older pygtks
            #http://bugzilla.gnome.org/show_bug.cgi?id=318874 #pygtk-2.8.[12]
            #Note pygtk-2.8.1 was released with ubuntu breezy :(
            self.LEFT_PTR_WATCH=None #default cursor
        self.SB_V_DOUBLE_ARROW=gtk.gdk.Cursor(gtk.gdk.SB_V_DOUBLE_ARROW)
        self.XTERM=gtk.gdk.Cursor(gtk.gdk.XTERM) #I beam
        self.WATCH=gtk.gdk.Cursor(gtk.gdk.WATCH) #hourglass

    def get_fslint(self, command, delim='\n'):
        self.fslintproc = subProcess(command)
        self.status.set_text(_("searching")+"...")
        while self.fslintproc.read(timeout=0.1):
            while gtk.events_pending(): gtk.main_iteration(False)
            if self.stopflag:
                if self.paused:
                    self.fslintproc.resume()
                self.fslintproc.kill()
                break
            elif self.pauseflag:
                self.pause_search()
        else:
            self.fslintproc.outdata=self.fslintproc.outdata.split(delim)[:-1]
            ret = (self.fslintproc.outdata, self.fslintproc.errdata)
        #we can't control internal processing at present so hide buttons
        self.pause.hide()
        self.resume.hide()
        self.stop.hide()
        self.status.set_text(_("processing..."))
        while gtk.events_pending(): gtk.main_iteration(False)
        del(self.fslintproc)
        if self.stopflag:
            raise self.UserAbort
        else:
            return ret

    def ShowErrors(self, lines):
        if len(lines) == 0:
            return
        end=self.errors.get_buffer().get_end_iter()
        self.errors.get_buffer().insert(end,I18N.displayable_utf8(lines,"\n"))

    def ClearErrors(self):
        self.errors.get_buffer().set_text("")

    def buildFindParameters(self):
        if self.mode == self.mode_sn:
            if self.chk_sn_path.get_active():
                return ""
        elif self.mode == self.mode_ns:
            if self.chk_ns_path.get_active():
                return ""
        elif self.mode == self.mode_pkgs:
            return ""

        if self.ok_dirs.rows == 0:
            return _("No search paths specified")

        search_dirs = ""
        for row in range(self.ok_dirs.rows):
            search_dirs += " " + pipes.quote(self.ok_dirs.get_row_data(row))

        exclude_dirs=""
        # One can't remove directories listed as empty if
        # they have .git/ dirs etc. so ignore the exluded paths here
        if self.mode != self.mode_ed:
            for row in range(self.bad_dirs.rows):
                if exclude_dirs == "":
                    exclude_dirs = '\(' + ' -path '
                else:
                    exclude_dirs += ' -o -path '
                exclude_dirs += pipes.quote(self.bad_dirs.get_row_data(row))
        if exclude_dirs != "":
            exclude_dirs += ' \) -prune -o '

        if not self.recurseDirs.get_active():
            recurseParam=" -r "
        else:
            recurseParam=" "

        self.findParams = search_dirs + " -f " + recurseParam + exclude_dirs

        if self.mode == self.mode_up:
            min_size = self.min_size.get_text()
            if min_size == '0' or min_size == '':
                min_size=''
            elif min_size[-1].isdigit():
                min_size=str(int(min_size)-1)
                min_size += 'c'
            if min_size:
                self.findParams += '-size +' + min_size + ' '

        self.findParams += self.extra_find_params.get_text()

        return ""

    def addDirs(self, dirlist, dirs):
        """Adds items to passed clist."""
        dirlist.append([I18N.displayable_utf8(dirs,path=True)])
        dirlist.set_row_data(dirlist.rows-1, dirs)

    def removeDirs(self, dirlist):
        """Removes selected items from passed clist.
           If no items selected then list is cleared."""
        paths_to_remove = dirlist.selection
        if len(paths_to_remove) == 0:
            dirlist.clear()
        else:
            paths_to_remove.sort() #selection order irrelevant/problematic
            paths_to_remove.reverse() #so deleting works correctly
            for row in paths_to_remove:
                dirlist.remove(row)
            dirlist.select_row(dirlist.focus_row,0)

    def clist_alloc_colour(self, clist, colour):
        """cache colour allocation for clist
           as colour will probably be used multiple times"""
        cmap = clist.get_colormap()
        cmap_cache=clist.get_data("cmap_cache")
        if cmap_cache == None:
            cmap_cache={'':None}
        if colour not in cmap_cache:
            cmap_cache[colour]=cmap.alloc_color(colour)
        clist.set_data("cmap_cache",cmap_cache)
        return cmap_cache[colour]

    def clist_append_path(self, clist, path, colour, *rest):
        """append path to clist, handling utf8 and colour issues"""
        colour = self.clist_alloc_colour(clist, colour)
        utf8_path=I18N.displayable_utf8(path,path=True)
        (dir,file)=os.path.split(utf8_path)
        clist.append((file,dir)+rest)
        row_data = clist.get_data("row_data")
        row_data.append(path+'\n') #add '\n' so can write with writelines
        if colour:
            clist.set_foreground(clist.rows-1,colour)

    def clist_append_group_row(self, clist, cols):
        """append header to clist"""
        clist.append(cols)
        row_data = clist.get_data("row_data")
        row_data.append('#'+"\t".join(cols).rstrip()+'\n')
        clist.set_background(clist.rows-1,self.bg_colour)
        clist.set_selectable(clist.rows-1,0)

    def clist_remove_handled_groups(self, clist):
        row_data = clist.get_data("row_data")
        rowver=clist.rows
        rows_left = range(rowver)
        rows_left.reverse()
        for row in rows_left:
            if not get_selectable(row, row_data):
                if row == clist.rows-1 or not get_selectable(row+1, row_data):
                    clist.remove(row)
                    row_data.pop(row)
            else: #remove single item groups
                if row == clist.rows-1 and not get_selectable(row-1, row_data):
                    clist.remove(row)
                    row_data.pop(row)
                elif not ((row!=0 and get_selectable(row-1, row_data)) or
                          (row!=clist.rows-1 and get_selectable(row+1, row_data))):
                    clist.remove(row)
                    row_data.pop(row)

    def whatRequires(self, packages, level=0):
        if not packages: return
        if level==0: self.checked_pkgs={}
        for package in packages:
            #puts("\t"*level+package)
            self.checked_pkgs[package]=''
        if dist_type.rpm:
            cmd  = r"rpm -e --test " + ' '.join(packages) + r" 2>&1 | "
            cmd += r"sed -n 's/-[0-9]\{1,\}:/-/; " #strip epoch
            cmd += r"        s/.*is needed by (installed) \(.*\)/\1/p' | "
            cmd += r"LANG=C sort | uniq"
        elif dist_type.dpkg:
            cmd  = r"dpkg --purge --dry-run " + ' '.join(packages) + r" 2>&1 | "
            cmd += r"sed -n 's/ \(.*\) depends on.*/\1/p' | "
            cmd += r"LANG=C sort | uniq"
        elif dist_type.pacman:
            cmd  = r"LC_ALL=C pacman -Qi " + ' '.join(packages)
            cmd += r" 2>/dev/null | tr '\n' ' ' | "
            cmd += r"sed -e 's/Name .* Required By \{1,\}: \{1,\}//' -e "
            cmd += r"'s/Conflicts With .*//' -e 's/ \{18\}//g' -e "
            cmd += r"'s/ \{1,\}$/\n/'"
        else:
            raise RuntimeError("unknown distro")
        process = os.popen(cmd)
        requires = process.read()
        del(process)
        new_packages = [p for p in requires.split()
                        if p not in self.checked_pkgs]
        self.whatRequires(new_packages, level+1)
        if level==0: return self.checked_pkgs.keys()

    def findpkgs(self, clist_pkgs):
        self.clist_pkgs_order=[False,False] #unordered, descending
        self.clist_pkgs_user_input=False
        self.pkg_info.get_buffer().set_text("")
        if dist_type.dpkg:
            #Package names unique on debian
            cmd  = r"dpkg-query -W --showformat='${Package}\t${Installed-Size}"
            cmd += r"\t${Status}\n' | LANG=C grep -F 'installed' | cut -f1,2 | "
            cmd += r"sed 's/[^0-9]$/\t0/'" #packages with missing size = 0
        elif dist_type.rpm:
            #Must include version names to uniquefy on redhat
            cmd  = r"rpm -qa --queryformat '%{N}-%{V}-%{R}.%{ARCH}\t%{SIZE}\n'"
        elif dist_type.pacman:
            cmd  = r"pacman -Q | sed -n 's/^\([^ ]\{1,\}\) .*/\1/p' | "
            cmd += r"LC_ALL=C xargs pacman -Qi | sed -n -e "
            cmd += r"'s/Installed Size : \([^ ]*\) \([^ ]*\)B/\1\2/p' | "
            cmd += r"numfmt --from=auto"
        else:
            return ("", _("Sorry, FSlint does not support this functionality \
on your system at present."))
        po, pe = self.get_fslint(cmd + " | LANG=C sort -k2,2rn")
        pkg_tot = 0
        row = 0
        for pkg_info in po:
            pkg_name, pkg_size= pkg_info.split()
            pkg_size = int(float(pkg_size))
            if dist_type.dpkg:
                pkg_size *= 1024
            pkg_tot += pkg_size
            clist_pkgs.append([pkg_name,human_num(pkg_size,1000).strip(),
                               "%010ld"%pkg_size,"0"])
            clist_pkgs.set_row_data(row, pkg_name)
            row += 1

        return (str(row) + _(" packages, ") +
                _("consuming %sB. ") % human_num(pkg_tot,1000).strip() +
                _("Note %s.") % human_space_left('/'), pe)
        #Note pkgs generally installed on root partition so report space left.

    def findrs(self, clist_rs):
        options=""
        if self.chkWhitespace.get_active():
            options += "-w "
        if self.chkTabs.get_active():
            options += "-t%d " % int(self.spinTabs.get_value())
        if not options:
            return ("","")
        po, pe = self.get_fslint("./findrs " + options + self.findParams)
        row = 0
        for line in po:
            pi = pathInfo(line)
            self.clist_append_path(clist_rs, line,
                                   pi.ls_colour, str(pi.size), pi.ls_date)
            row += 1

        return (str(row) + _(" files"), pe)

    def findns(self, clist_ns):
        cmd = "./findns "
        if not self.chk_ns_path.get_active():
            cmd += self.findParams
        po, pe = self.get_fslint(cmd)

        unstripped=[]
        for line in po:
            pi = pathInfo(line)
            unstripped.append((pi.size, line, pi.ls_date))
        unstripped.sort()
        unstripped.reverse()

        row = 0
        for size, path, ls_date in unstripped:
            self.clist_append_path(clist_ns, path, '', human_num(size), ls_date)
            row += 1

        return (str(row) + _(" unstripped binaries"), pe)

    def finded(self, clist_ed):
        po, pe = self.get_fslint("./finded " + self.findParams, '\0')
        row = 0
        for line in po:
            self.clist_append_path(clist_ed, line, '', pathInfo(line).ls_date)
            row += 1

        return (str(row) + _(" empty directories"), pe)

    def findid(self, clist_id):
        po, pe = self.get_fslint("./findid " + self.findParams, '\0')
        row = 0
        for record in po:
            pi = pathInfo(record)
            self.clist_append_path(clist_id, record, pi.ls_colour, str(pi.uid),
                                   str(pi.gid), str(pi.size), pi.ls_date)
            row += 1

        return (str(row) + _(" files"), pe)

    def findbl(self, clist_bl):
        cmd = "./findbl " + self.findParams
        if self.opt_bl_dangling.get_active():
            cmd += " -d"
        elif self.opt_bl_suspect.get_active():
            cmd += " -s"
        elif self.opt_bl_relative.get_active():
            cmd += " -l"
        elif self.opt_bl_absolute.get_active():
            cmd += " -A"
        elif self.opt_bl_redundant.get_active():
            cmd += " -n"
        po, pe = self.get_fslint(cmd)
        row = 0
        for line in po:
            link, target = line.split(" -> ", 2)
            self.clist_append_path(clist_bl, link, '', target)
            row += 1

        return (str(row) + _(" links"), pe)

    def findtf(self, clist_tf):
        cmd = "./findtf " + self.findParams
        cmd += " --age=" + str(int(self.spin_tf_core.get_value()))
        if self.chk_tf_core.get_active():
            cmd += " -c"
        po, pe = self.get_fslint(cmd)
        row = 0
        byteWaste = 0
        for line in po:
            pi = pathInfo(line)
            self.clist_append_path(clist_tf, line, '', str(pi.size), pi.ls_date)
            byteWaste += pi.du
            row += 1

        return (human_num(byteWaste,1000).strip() + 'B' + _(" wasted in ") +
                str(row) + _(" files"), pe)

    def findsn(self, clist_sn):
        cmd = "./findsn "
        if self.chk_sn_path.get_active():
            option = self.opt_sn_path.get_children()[0].get()
            if option == _("Aliases"):
                cmd += " -A"
            elif option == _("Conflicting files"):
                pass #default mode
            else:
                raise RuntimeError("glade GtkOptionMenu item not found")
        else:
            cmd += self.findParams
            option = self.opt_sn_paths.get_children()[0].get()
            if option == _("Aliases"):
                cmd += " -A"
            elif option == _("Same names"):
                pass #default mode
            elif option == _("Same names(ignore case)"):
                cmd += " -C"
            elif option == _("Case conflicts"):
                cmd += " -c"
            else:
                raise RuntimeError("glade GtkOptionMenu item not found")

        po, pe = self.get_fslint(cmd,'\0')
        po = po[1:]
        row=0
        findsn_number=0
        findsn_groups=0
        for record in po:
            if record == '':
                self.clist_append_group_row(clist_sn, ['','',''])
                findsn_groups += 1
            else:
                pi = pathInfo(record)
                self.clist_append_path(clist_sn, record,
                                       pi.ls_colour, str(pi.size))
                clist_sn.set_row_data(clist_sn.rows-1, pi.mtime)
                findsn_number += 1
            row += 1
        if findsn_number:
            findsn_groups += 1 #for stripped group head above

        return (str(findsn_number) + _(" files (in ") + str(findsn_groups) +
                _(" groups)"), pe)

    def findnl(self, clist_nl):
        if self.chk_findu8.get_active():
            po, pe = self.get_fslint("./findu8 " + self.findParams, '\0')
        else:
            sensitivity = ('1','2','3','p')[
            int(self.hscale_findnl_level.get_adjustment().value)-1]
            po, pe = self.get_fslint("./findnl " + self.findParams + " -" +
                                    sensitivity, '\0')

        row=0
        for record in po:
            self.clist_append_path(clist_nl, record, pathInfo(record).ls_colour)
            row += 1

        return (str(row) + _(" files"), pe)

    def findup(self, clist_dups):
        po, pe = self.get_fslint("./findup --gui" + self.findParams)

        numdups = 0
        du = size = 0
        dups = []
        alldups = []
        inodes = {}
        #inodes required to correctly report disk usage of
        #duplicate files with seperate inode groups.
        for line in po:
            if line == '': #grouped == 1
                if len(inodes)>1:
                    alldups.append(((numdups-1)*du, numdups, size, dups))
                dups = []
                numdups = 0
                inodes = {}
            else:
                try:
                    pi = pathInfo(line)
                    size, du = (pi.size, pi.du)
                    dups.append((line, pi.ls_date, pi.mtime))
                    if pi.inode not in inodes:
                        inodes[pi.inode] = True
                        numdups += 1
                except OSError:
                    #file may have been deleted, changed permissions, ...
                    self.ShowErrors(str(sys.exc_info()[1])+'\n')
        else:
            if len(inodes)>1:
                alldups.append(((numdups-1)*du, numdups, size, dups))

        alldups.sort()
        alldups.reverse()

        byteWaste = 0
        numWaste = 0
        row=0
        for groupWaste, groupSize, size, files in alldups:
            byteWaste += groupWaste
            numWaste += groupSize - 1
            groupHeader = ["%d x %s" % (groupSize, human_num(size)),
                           "(%s)" % human_num(groupWaste),
                           _("bytes wasted")]
            self.clist_append_group_row(clist_dups, groupHeader)
            row += 1
            for file in files:
                self.clist_append_path(clist_dups,file[0],'',file[1])
                clist_dups.set_row_data(row,file[2]) #mtime
                row += 1

        return (human_num(byteWaste,1000).strip() + 'B' + _(" wasted in ") +
                str(numWaste) + _(" files (in ") + str(len(alldups)) +
                _(" groups)"), pe)

    find_dispatch = (findup,findpkgs,findnl,findsn,findtf,
                     findbl,findid,finded,findns,findrs) #order NB

    def set_cursor(self, requested_cursor):
        #TODO: horizontal arrows for GtkClist column resize handles not set
        cursor=requested_cursor
        if not self.GtkWindow.window: return #window closed
        self.GtkWindow.window.set_cursor(cursor)
        if requested_cursor==None: cursor=self.XTERM #I beam
        for gtkentry in (self.status, self.extra_find_params):
            if not gtkentry.window: continue #not realised yet
            gtkentry.window.set_cursor(cursor)
            gtkentry.window.get_children()[0].set_cursor(cursor)
        for gtkspinbutton in (self.spin_tf_core, self.spinTabs):
            if not gtkspinbutton.window: continue #not realised yet
            gtkspinbutton.window.set_cursor(cursor)
            gtkspinbutton.window.get_children()[0].set_cursor(cursor)
        for gtktextview in (self.errors,):
            if not gtktextview.window: continue #not realised yet
            gtktextview.window.set_cursor(cursor)
            gtktextview.get_window(gtk.TEXT_WINDOW_TEXT).set_cursor(cursor)
        if requested_cursor==None: cursor=self.SB_V_DOUBLE_ARROW
        for gtkpaned in (self.vpanes,):
            if not gtkpaned.window: continue #not realised yet
            try:
                handle_size=gtkpaned.style_get_property("handle-size")#pygtk-2.4
            except:
                break
            for window in gtkpaned.window.get_children():
                width,height=window.get_size()
                if width==handle_size or height==handle_size:
                    window.set_cursor(cursor)
        while gtk.events_pending(): gtk.main_iteration(False)

    def look_busy(self):
        self.find.hide()
        self.resume.hide()
        self.stop.show()
        self.pause.show()
        self.stop.grab_focus()
        self.control_buttons.grab_add() #restrict mouse and key presses to here
        self.set_cursor(self.LEFT_PTR_WATCH)

    def look_interactive(self):
        self.control_buttons.grab_remove()
        self.stop.hide()
        self.resume.hide()
        self.pause.hide()
        self.find.show()
        self.find.grab_focus() #as it already would have been in focus
        self.set_cursor(None)

    def msgbox(self, message, buttons=('Ok',), entry_default=None,
               again=False, again_val=True):
        msgbox=dlgUserInteraction(liblocation+"/fslint.glade","UserInteraction")
        msgbox.init(self, message, buttons, entry_default, again, again_val)
        msgbox.show()
        response = (msgbox.response,)
        if hasattr(msgbox, "input"):
            response += (msgbox.input,)
        if hasattr(msgbox, "again"):
            response += (msgbox.again,)
        return response

    #Return tuple of booleans meaning: (user_ok_with_action, ask_again)
    def check_user(self, question):
        self.ClearErrors()
        #remove as status from previous operation could be confusing
        self.status.delete_text(0,-1)
        clist = self.clists[self.mode]
        if not clist.rows:
            return False, True #Be consistent
                         #All actions buttons do nothing if no results
        paths = clist.selection
        if len(paths) == 0:
            self.ShowErrors(_("None selected"))
            return False, True
        else:
            if len(paths) == 1:
                question += _(" this item?\n")
            else:
                question += _(" these %d items?\n") % len(paths)
            (response, again) = self.msgbox(question, ('Yes', 'No'), again=True)
            if response != "Yes":
                return (False, again)
            return (True, again)

    #################
    # Signal handlers
    #################

    def on_fslint_destroy(self, event):
        try:
            if self.paused:
                self.fslintproc.resume()
            self.fslintproc.kill()
            del(self.fslintproc)
        except:
            pass #fslint wasn't searching
        gtk.main_quit()

    def on_addOkDir_clicked(self, event):
        self.dlgPath.show()
        if not self.dlgPath.canceled:
            paths = self.dlgPath.GtkWindow.get_filenames()
            for path in paths:
                path = os.path.normpath(path)
                self.addDirs(self.ok_dirs, path)

    def on_addBadDir_clicked(self, event):
        self.dlgPath.show()
        if not self.dlgPath.canceled:
            paths = self.dlgPath.GtkWindow.get_filenames()
            for path in paths:
                path = self.dlgPath.GtkWindow.get_filename()
                path = os.path.normpath(path)
                #Note find -path doesn't match dirs with trailing /
                #and normpath strips trailing / among other things
                #XXX: The following is not robust. We really should
                #split specifying wildcards and paths
                if not os.path.exists(path): #probably a wildcard?
                    #hacky way to get just user specified component
                    dirs = path.split('/')
                    if len(dirs) > 2:
                        for i in range(len(dirs)):
                            path = '/'.join(dirs[:i+1])
                            if path and not os.path.exists(path):
                                path = '/'.join(dirs[i:])
                                break
                    if '/' not in path:
                        path = "*/" + path #more accurate
                self.addDirs(self.bad_dirs, path)

    def on_removeOkDir_clicked(self, event):
        self.removeDirs(self.ok_dirs)

    def on_removeBadDir_clicked(self, event):
        self.removeDirs(self.bad_dirs)

    def on_chk_sn_path_toggled(self, event):
        if self.chk_sn_path.get_active():
            self.hbox_sn_paths.hide()
            self.hbox_sn_path.show()
        else:
            self.hbox_sn_path.hide()
            self.hbox_sn_paths.show()

    def on_chk_findu8_toggled(self, event):
        if self.chk_findu8.get_active():
            self.hscale_findnl_level.hide()
            self.lbl_findnl_sensitivity.hide()
        else:
            self.hscale_findnl_level.show()
            self.lbl_findnl_sensitivity.show()

    def on_fslint_functions_switch_page(self, widget, dummy, pagenum):
        self.ClearErrors()
        self.mode=pagenum
        self.status.set_text(self.mode_descs[self.mode])
        if self.mode == self.mode_up:
            self.autoMerge.show()
            self.autoSymlink.show()
        else:
            self.autoMerge.hide()
            self.autoSymlink.hide()
        if self.mode == self.mode_ns or self.mode == self.mode_rs: #bl in future
            self.autoClean.show()
        else:
            self.autoClean.hide()

    def on_selection_menu_button_press_event(self, widget, event):
        if self.mode == self.mode_up or self.mode == self.mode_sn:
            self.groups_menu.show()
        else:
            self.groups_menu.hide()
        if event == None: #standard button click
            self.selection_menu_menu.popup(None,None,None,0,0) #at mouse pointer
        elif type(widget) == gtk.CList and self.mode != self.mode_pkgs:
            if event.button == 1 and event.type == gtk.gdk._2BUTTON_PRESS:
                #Notes:
                # This clause is not related to selection menu, but this
                # is the button_press handler for all lists so leaving here.
                # widget.selection can be empty due to doing this in
                # button press rather than button release I think.
                # Ignoring widget.selection allows us to ctrl-doubleclick
                # to open additional items being added to a selection.
                sel=widget.get_selection_info(int(event.x),int(event.y))
                if sel:
                    row,col=sel
                    if widget.get_selectable(row)==True:
                        self.on_open_activate(event,row)
            elif event.button == 3:
                menu=self.selection_menu_menu
                sel=widget.get_selection_info(int(event.x),int(event.y))
                if sel:
                    row,col=sel
                    selected = widget.selection
                    if len(selected)==1 and row in selected:
                        menu=self.edit_menu_menu
                menu.popup(None,None,None,event.button,event.time)

    def on_find_clicked(self, event):

        try:
            status=""
            errors=""
            self.ClearErrors()
            clist = self.clists[self.mode]
            os.chdir(liblocation+"/fslint/")
            errors = self.buildFindParameters()
            if errors:
                self.ShowErrors(errors)
                return
            self.status.delete_text(0,-1)
            clist.clear()
            #All GtkClist operations seem to be O(n),
            #so doing the following for example will be O((n/2)*(n+1))
            #    for row in xrange(clist.rows):
            #        path = clist.get_row_data(row)
            #Therefore we use a python list to store row data.
            clist.set_data("row_data",[])
            if self.mode == self.mode_pkgs:
                self.pkg_info.get_buffer().set_text("")
            self.look_busy()
            self.stopflag=self.pauseflag=False
            self.paused = False
            while gtk.events_pending(): gtk.main_iteration(False)#update GUI
            clist.freeze()
            tstart=time.time()
            status, errors=self.__class__.find_dispatch[self.mode](self, clist)
            tend=time.time()
            if time_commands:
                status += ". Found in %.3fs" % (tend-tstart)
        except self.UserAbort:
            status=_("User aborted")
        except:
            etype, emsg, etb = sys.exc_info()
            errors=str(etype)+': '+str(emsg)+'\n'
        clist.columns_autosize()
        clist.thaw()
        os.chdir(self.pwd)
        self.ShowErrors(errors)
        self.status.set_text(status)
        self.look_interactive()

    def on_stop_clicked(self, event):
        self.stopflag=True

    def on_pause_clicked(self, event):
        # self.fslintproc may not be created yet,
        # so set the flag and pause in get_fslint()
        self.pauseflag=True

    def pause_search(self):
        self.pauseflag=False
        self.paused = not self.paused
        if self.paused:
            self.pause.hide()
            self.resume.show()
            self.resume.grab_focus()
            self.fslintproc.pause()
            self.status.set_text(_("paused"))
        else:
            self.resume.hide()
            self.pause.show()
            self.pause.grab_focus()
            self.fslintproc.resume()
            #We can only pause external searching
            self.status.set_text(_("searching")+"...")
        while gtk.events_pending(): gtk.main_iteration(False)

    def on_control_buttons_keypress(self, button, event):
        #ingore capslock and numlock
        state = event.state & ~(gtk.gdk.LOCK_MASK | gtk.gdk.MOD2_MASK)
        ksyms=gtk.keysyms
        abort_keys={
                    int(gtk.gdk.CONTROL_MASK):[ksyms.c,ksyms.C],
                    0                        :[ksyms.Escape]
                   }
        try:
            if event.keyval in abort_keys[state]:
                self.on_stop_clicked(event)
        except:
            pass
        if event.keyval in (ksyms.Tab, ksyms.Left, ksyms.Right):
            # Unfortunately GTK doesn't restrict widgets
            # to focus to children of the current grab_add widget.
            # So we do it manually here.
            if self.stop.is_focus():
                if self.paused:
                    self.resume.grab_focus()
                else:
                    self.pause.grab_focus()
            else:
                self.stop.grab_focus()
            return True #Don't allow moving to other controls
        elif event.keyval in (ksyms.Return, ksyms.space):
            return False #pass event on to sub button
        else:
            return True #Don't pass on up/down arrows etc.

    #Note Ctrl-C as well as doing "copy path" which is handled here,
    #also cancels a find in progress. That doesn't need to be handled here
    #because the control buttons grab focus during the find operation.
    #
    #Note also that, we need a global handler here for all lists
    #as in GTK, keyboard events specifically are sent to the window first,
    #rather than the widget. The alternative is to add handlers to all lists.
    def on_fslint_keypress(self, button, event):
        #ingore capslock and numlock
        state = event.state & ~(gtk.gdk.LOCK_MASK | gtk.gdk.MOD2_MASK)
        ksyms=gtk.keysyms
        if state == int(gtk.gdk.CONTROL_MASK):
            if event.keyval in (ksyms.c, ksyms.C):
                self.on_copy_activate(event)
            elif event.keyval in (ksyms.o, ksyms.O):
                self.on_open_activate(event)
        elif state == 0:
            if event.keyval in (ksyms.F2,):
                self.on_rename_activate(event)
            elif event.keyval in (ksyms.Return,):
                self.on_open_activate(event)
            elif event.keyval in (ksyms.Delete,):
                if self.ok_dirs.flags() & gtk.HAS_FOCUS:
                    self.on_removeOkDir_clicked(event)
                elif self.bad_dirs.flags() & gtk.HAS_FOCUS:
                    self.on_removeBadDir_clicked(event)
                elif self.clists[self.mode].flags() & gtk.HAS_FOCUS:
                    self.on_delSelected_clicked(event)

    def on_saveAs_clicked(self, event):
        clist = self.clists[self.mode]
        if clist.rows == 0:
            return
        self.dlgPath.show(fileOps=True)
        if not self.dlgPath.canceled:
            self.ClearErrors()
            fileSaveAs = self.dlgPath.GtkWindow.get_filename()
            try:
                fileSaveAs = open(fileSaveAs, 'w')
            except:
                etype, emsg, etb = sys.exc_info()
                self.ShowErrors(str(emsg)+'\n')
                return
            rows_to_save = clist.selection
            if self.mode == self.mode_pkgs:
                for row in xrange(clist.rows):
                    if len(rows_to_save):
                        if row not in rows_to_save: continue
                    rowtext = ''
                    for col in (0,2): #ignore "human number" col
                        rowtext += clist.get_text(row,col) +'\t'
                    fileSaveAs.write(rowtext[:-1]+'\n')
            else:
                row_data=clist.get_data("row_data")
                if len(rows_to_save):
                    for row in xrange(clist.rows):
                        if get_selectable(row, row_data):
                            if row not in rows_to_save: continue
                        else: continue #don't save group headers
                        fileSaveAs.write(row_data[row])
                else:
                    fileSaveAs.writelines(row_data)

    def get_selected_path(self, row=None, folder=False):
        clist = self.clists[self.mode]
        if self.mode==self.mode_pkgs:
            return None
        if row==None and len(clist.selection)!=1:
            return None

        row_data=clist.get_data("row_data")
        if row==None:
            row = clist.selection[0] #menu item only enabled if 1 item selected
        disp_path=os.path.join(clist.get_text(row,1), clist.get_text(row,0))
        path=row_data[row][:-1] #actual full path
        urlencode = (path != disp_path)

        if folder:
            path=os.path.split(path)[0]

        if urlencode:
            import urllib
            path="file://"+urllib.pathname2url(path)

        return path

    def on_copy_activate(self, src):
        path = self.get_selected_path()
        if path:
            clipboard=self.GtkWindow.get_clipboard("CLIPBOARD")
            clipboard.set_text(path, -1)

    def on_open_folder_activate(self, src, row=None):
        self.on_open_activate(src, row, folder=True)

    def on_open_activate(self, src, row=None, folder=False):
        path = self.get_selected_path(row, folder)
        if path:
            #Note we can't use subProcess() or os.popen3() to read errors,
            #as stdout & stderr of the resulting GUI program will be
            #connected to its pipes and so we will hang on read().
            #Note also that xdg-open doesn't identify the desktop platform
            #correctly when running (FSlint) on a remote X session.
            path = pipes.quote(path)
            if os.system("xdg-open %s >/dev/null 2>&1" % path):
                #could run again with os.popen3() to get actual error
                #but that's a bit hacky I think?
                self.ShowErrors(_("Error starting xdg-open") + '\n')

    # select all other duplicates from selected item folder
    def on_select_from_that_folder_activate(self, src):
        clist = self.clists[self.mode]
        if self.mode==self.mode_pkgs or len(clist.selection)!=1:
            return
        row = clist.selection[0] #menu item only enabled if 1 item selected
        row_data = clist.get_data("row_data")
        path = os.path.split(row_data[row])[0]
        select_func=clist.select_row
        for row in xrange(clist.rows):
            if os.path.split(row_data[row])[0] == path:
                select_func(row, 0)

    def on_rename_activate(self, src):
        clist = self.clists[self.mode]
        if self.mode==self.mode_pkgs or len(clist.selection)!=1:
            return

        row_data=clist.get_data("row_data")
        row=clist.selection[0] #menu item only enabled if 1 item selected
        utf8_name=clist.get_text(row,0)
        path_name=row_data[row][:-1]

        (response,new_path)=self.msgbox(_("Rename:"),('Cancel','Ok'),utf8_name)
        if response != "Ok":
            return

        self.ClearErrors()
        if not (self.mode==self.mode_nl and self.chk_findu8.get_active()):
            try:
                new_encoded_path=I18N.g_filename_from_utf8(new_path)
            except UnicodeEncodeError:
                new_encoded_path=None
                self.ShowErrors(_(
                "Error: [%s] can not be represented on your file system") %\
                (new_path) +'\n')
        else:
            new_encoded_path=new_path #leave in (displayable) utf-8
        if new_encoded_path:
            dir,base=os.path.split(path_name)
            new_encoded_path=dir+'/'+new_encoded_path
            if os.path.exists(new_encoded_path):
                translation_map={"old_path":utf8_name, "new_path":new_path}
                self.ShowErrors(_(
                "Error: Can't rename [%(old_path)s] as "\
                "[%(new_path)s] exists") % translation_map + '\n')
            else:
                try:
                    os.rename(path_name, new_encoded_path)
                    row_data.pop(row)
                    clist.remove(row)
                    if self.mode!=self.mode_up:
                        # We may want to delete the other item
                        # in a group of two
                        self.clist_remove_handled_groups(clist)
                except OSError:
                    self.ShowErrors(str(sys.exc_info()[1])+'\n')

    def on_unselect_using_wildcard_activate(self, event):
        self.select_using_wildcard(False)
    def on_select_using_wildcard_activate(self, event):
        self.select_using_wildcard(True)
    def select_using_wildcard(self, select):
        clist = self.clists[self.mode]
        if clist.rows == 0:
            return

        (response, wildcard) = self.msgbox(_("wildcard:"), ('Cancel', 'Ok'))
        if response!="Ok" or not wildcard:
            return

        self.ClearErrors()
        if '/' in wildcard:
            #Convert from utf8 if required so can match non utf-8 paths
            try:
                wildcard=I18N.g_filename_from_utf8(wildcard)
            except UnicodeEncodeError:
                self.ShowErrors(_(
                "Error: [%s] can not be represented on your file system") %\
                (wildcard) +'\n')
                return
        else:
            #Convert to unicode to match unicode string below
            wildcard=unicode(wildcard, "utf-8")
        select_func=(select and clist.select_row or clist.unselect_row)
        if '/' not in wildcard or self.mode == self.mode_pkgs:
            #Convert to unicode so ? in glob matching works correctly
            get_text = lambda row: unicode(clist.get_text(row,0),"utf-8")
        else: #Note fnmatch ignores trailing \n
            row_data = clist.get_data("row_data")
            get_text = lambda row: row_data[row]
        import fnmatch
        for row in xrange(clist.rows):
            if fnmatch.fnmatch(get_text(row), wildcard):
                select_func(row, 0)

    def on_select_all_but_first_in_each_group_activate(self, event):
        self.on_select_all_but_one_in_each_group_activate("first")
    def on_select_all_but_newest_in_each_group_activate(self, event):
        self.on_select_all_but_one_in_each_group_activate("newest")
    def on_select_all_but_oldest_in_each_group_activate(self, event):
        self.on_select_all_but_one_in_each_group_activate("oldest")

    def on_select_all_but_one_in_each_group_activate(self, which):

        def find_row_to_unselect(clist, row, which):
            import operator
            if which == "first":
                if row==0 and get_selectable(row, row_data):
                    return row #for first row in clist_sn
                else:
                    return row+1
            elif which == "newest":
                unselect_mtime=-1
                comp=operator.gt
            elif which == "oldest":
                unselect_mtime=2**32
                comp=operator.lt
            if row!=0 or not get_selectable(row, row_data):
                row += 1 #for all except first row in clist_sn
            unselect_row = -1 # avoid rh bug 726252 (mtimes for group = -1?)
            while row < clist.rows and get_selectable(row, row_data):
                mtime = clist.get_row_data(row)
                if comp(mtime,unselect_mtime):
                    unselect_mtime = mtime
                    unselect_row=row
                row += 1
            return unselect_row

        clist = self.clists[self.mode]
        row_data = clist.get_data("row_data")
        clist.freeze()
        clist.select_all()
        for row in xrange(clist.rows):
            if row==0 or not get_selectable(row, row_data): #New group
                unselect_row = find_row_to_unselect(clist, row, which)
                if unselect_row == -1:
                    clist.unselect_all()
                    clist.thaw()
                    self.ShowErrors("Error getting age of group containing ["+
                                    self.get_selected_path(row=row+1)+']\n')
                    return
                clist.unselect_row(unselect_row, 0)
        clist.thaw()

    def find_group_with_all_selected(self, skip_groups=0):

        if self.mode != self.mode_up and self.mode != self.mode_sn:
            return False

        clist = self.clists[self.mode]
        selected = clist.selection
        if not selected:
            return False

        row_data = clist.get_data("row_data")

        def group_all_selected(clist, row):
            if row!=0 or not get_selectable(row, row_data): #for first sn row
                row += 1
            while row < clist.rows and get_selectable(row, row_data):
                if not row in selected:
                    return False
                row += 1
            return True

        group=1
        for row in xrange(clist.rows):
            if row==0 or not get_selectable(row, row_data): #New group
                if group_all_selected(clist, row):
                    if group > skip_groups:
                        clist.moveto(row,0,0.0,0.0)
                        return True
                    group += 1

        return False

    def on_unselect_all_activate(self, event):
        clist = self.clists[self.mode]
        clist.unselect_all()

    def on_toggle_selection_activate(self, event):
        clist = self.clists[self.mode]
        clist.freeze()
        selected = clist.selection
        if len(selected) == 0:
            clist.select_all()
        elif len(selected) == clist.rows:
            clist.unselect_all()
        else:
            clist.select_all()
            for row in selected:
                clist.unselect_row(row, 0)
        clist.thaw()

    def on_selection_clicked(self, widget):
        self.on_selection_menu_button_press_event(self.selection, None)

    def clist_pkgs_sort_by_selection(self, clist):
        selection = clist.selection
        for row in xrange(clist.rows):
            if row in selection:
                clist.set_text(row,3,"1")
            else:
                clist.set_text(row,3,"0")
        clist.set_sort_type(gtk.SORT_DESCENDING)
        clist.set_sort_column(3)
        clist.sort()
        clist.moveto(0,0,0.0,0.0)

    def on_clist_pkgs_click_column(self, clist, col):
        self.clist_pkgs_order[col] = not self.clist_pkgs_order[col]
        if self.clist_pkgs_order[col]:
            clist.set_sort_type(gtk.SORT_ASCENDING)
        else:
            clist.set_sort_type(gtk.SORT_DESCENDING)
        try:
            #focus_row is not updated after ordering, so can't use
            #last_selected=clist.get_row_data(clist.focus_row)
            last_selected=self.clist_pkgs_last_selected
        except:
            last_selected=0
        if col==0:
            clist.set_sort_column(0)
        else:
            clist.set_sort_column(2)
        clist.sort() #note ascii sort (locale ignored)
        #could instead just use our "row_data" and
        #repopulate the gtkclist with something like:
        #row_data = clist.get_data("row_data")
        #row_data.sort(key = lambda x:x[col],
        #              reverse = not self.clist_pkgs_order[col])
        if last_selected:
            #Warning! As of pygtk2-2.4.0 at least
            #find_row_from_data only compares pointers, not strings!
            last_selected_row=clist.find_row_from_data(last_selected)
            clist.moveto(last_selected_row,0,0.5,0.0)
            #clist.set_focus_row(last_selected_row)
        else:
            clist.moveto(0,0,0.0,0.0)

    #Note the events and event ordering provided by the GtkClist
    #make it very hard to provide robust and performant handlers
    #for selected rows. These flags are an attempt to stop the
    #function below from being called too frequently.
    #Note most users will scoll the list with {Up,Down} rather
    #than Ctrl+{Up,Down}, but at worst this will result in slow scrolling.
    def on_clist_pkgs_button_press(self, list, event):
        if event.button == 3:
            self.on_selection_menu_button_press_event(list, event)
        else:
            self.clist_pkgs_user_input=True
    def on_clist_pkgs_key_press(self, *args):
        self.clist_pkgs_user_input=True

    def on_clist_pkgs_selection_changed(self, clist, *args):
        self.pkg_info.get_buffer().set_text("")
        if not self.clist_pkgs_user_input:
            self.clist_pkgs_last_selected=False
            return
        self.clist_pkgs_user_input=False
        if len(clist.selection) == 0:
            return
        pkg=clist.get_row_data(clist.selection[-1])
        self.clist_pkgs_last_selected=pkg #for ordering later
        if dist_type.rpm:
            cmd = "rpm -q --queryformat '%{DESCRIPTION}' " + pkg
        elif dist_type.dpkg:
            cmd = "dpkg-query -W --showformat='${Description}' " + pkg
        elif dist_type.pacman:
            cmd =  "LC_ALL=C pacman -Qi " + pkg
            cmd += " | sed -n 's/Description *: *//p'"
        pkg_process = subProcess(cmd)
        pkg_process.read()
        lines=pkg_process.outdata
        self.pkg_info.get_buffer().set_text(I18N.displayable_utf8(lines,"\n"))
        del(pkg_process)

    def on_delSelected_clicked(self, src):
        if self.mode == self.mode_pkgs:
            if os.geteuid() != 0:
                self.msgbox(
                  _("Sorry, you must be root to delete system packages.")
                )
                return
        if self.confirm_delete:
            (response, self.confirm_delete) =\
            self.check_user(_("Are you sure you want to delete"))
            if not response:
                return
        skip_groups=0
        while self.confirm_delete_group and \
              self.find_group_with_all_selected(skip_groups):
            (response, self.confirm_delete_group) = self.msgbox(
              _("Are you sure you want to delete all items in this group?"),
              ('Yes', 'No'), again=True)
            if response != "Yes":
                return
            skip_groups += 1

        self.set_cursor(self.WATCH)
        clist = self.clists[self.mode]
        row_data = clist.get_data("row_data")
        paths_to_remove = clist.selection
        paths_to_remove.sort() #selection order irrelevant/problematic
        paths_to_remove.reverse() #so deleting works correctly
        numDeleted = 0
        if self.mode == self.mode_pkgs:
            #get pkg names to delete
            pkgs_selected = []
            for row in paths_to_remove:
                package = clist.get_row_data(row)
                pkgs_selected.append(package)
            #determine if we need to select more packages
            self.status.set_text(_("Calculating dependencies..."))
            while gtk.events_pending(): gtk.main_iteration(False)
            all_deps=self.whatRequires(pkgs_selected)
            if len(all_deps) > len(pkgs_selected):
                num_new_pkgs = 0
                for package in all_deps:
                    if package not in pkgs_selected:
                        num_new_pkgs += 1
                        #Note clist.find_row_from_data() only compares pointers
                        for row in xrange(clist.rows):
                            if package == clist.get_row_data(row):
                                clist.select_row(row,0)

                #make it easy to review by grouping all selected packages
                self.clist_pkgs_sort_by_selection(clist)

                self.set_cursor(None)
                self.msgbox(
                  _("%d extra packages need to be deleted.\n") % num_new_pkgs +
                  _("Please review the updated selection.")
                )
                #Note this is not ideal as it's difficult for users
                #to get info on selected packages (Ctrl click twice).
                #Should really have a seperate marked_for_deletion  column.
                self.status.set_text("")
                return

            self.status.set_text(_("Removing packages..."))
            while gtk.events_pending(): gtk.main_iteration(False)
            if dist_type.rpm:
                cmd="rpm -e "
            elif dist_type.dpkg:
                cmd="dpkg --purge "
            elif dist_type.pacman:
                cmd="pacman -R "
            cmd += ' '.join(pkgs_selected) + " >/dev/null 2>&1"
            os.system(cmd)

        # Depth first traversal.
        # Any exception aborts.
        # os.walk available since python 2.3, but this is simpler.
        # We don't follow symlinks. They shouldn't be present in any case.
        def rm_branch(branch):
            for name in os.listdir(branch):
                name = os.path.join(branch, name)
                if os.path.isdir(name) and not os.path.islink(name):
                    rm_branch(name)
            os.rmdir(branch)

        clist.freeze()
        for row in paths_to_remove:
            if self.mode != self.mode_pkgs:
                try:
                    path=row_data[row][:-1] #strip trailing '\n'
                    if os.path.isdir(path):
                        rm_branch(path)
                    else:
                        os.unlink(path)
                except:
                    etype, emsg, etb = sys.exc_info()
                    self.ShowErrors(str(emsg)+'\n')
                    continue
                row_data.pop(row)
            clist.remove(row)
            numDeleted += 1

        if self.mode != self.mode_pkgs:
            self.clist_remove_handled_groups(clist)

        clist.select_row(clist.focus_row,0)

        clist.thaw()
        status = str(numDeleted) + _(" items deleted")
        if self.mode == self.mode_pkgs:
            status += ". " + human_space_left('/')
        self.status.set_text(status)
        self.set_cursor(None)

    def on_autoSymlink_clicked(self, event):
        self.on_autoMerge(symlink=True)

    def on_autoMerge_clicked(self, event):
        self.on_autoMerge(symlink=False)

    def on_autoMerge(self, symlink):
        self.ClearErrors()
        self.status.delete_text(0,-1)
        clist = self.clists[self.mode]
        if clist.rows < 3:
            return

        if symlink:
            question=_("Are you sure you want to symlink ALL files?\n")
        else:
            question=_("Are you sure you want to merge ALL files?\n")

        paths_to_leave = clist.selection
        if len(paths_to_leave):
            question += _("(Ignoring those selected)\n")

        (response,) = self.msgbox(question, ('Yes', 'No'))
        if response != "Yes":
            return

        self.set_cursor(self.WATCH)
        newGroup = False
        row_data=clist.get_data("row_data")
        for row in xrange(clist.rows):
            if row in paths_to_leave:
                continue
            if not get_selectable(row, row_data): #new group
                newGroup = True
            else:
                path = row_data[row][:-1] #strip '\n'
                if newGroup:
                    keepfile = path
                    newGroup = False
                else:
                    dupfile = path
                    dupdir = os.path.dirname(dupfile)
                    tmpfile = tempfile.mktemp(dir=dupdir)
                    try:
                        try:
                            if symlink:
                                os.symlink(os.path.realpath(keepfile),tmpfile)
                            else:
                                os.link(keepfile,tmpfile)
                        except OSError as value:
                            if value.errno == errno.EXDEV and not symlink:
                                os.symlink(os.path.realpath(keepfile),tmpfile)
                            else:
                                raise
                        os.rename(tmpfile, dupfile)
                        clist.set_background(row, self.bg_colour)
                    except OSError:
                        self.ShowErrors(str(sys.exc_info()[1])+'\n')
                    try:
                        #always try this as POSIX has bad requirement that
                        #rename(file1,file2) where both are links to the same
                        #file, does nothing, and returns success. So if user
                        #merges files multiple times, tmp files will be left.
                        os.unlink(tmpfile)
                    except:
                        pass
        self.set_cursor(None)

    def on_autoClean_clicked(self, event):
        if self.mode == self.mode_rs and self.chkTabs.get_active():
            (response,) = self.msgbox(
              _("Which indenting method do you want to convert to?"),
              (N_('Tabs'), N_('Spaces'), 'Cancel')
            )
            if response == "Spaces":
                indents="--indent-spaces"
            elif response == "Tabs":
                indents="--indent-tabs"
            else:
                return
        else:
            if self.confirm_clean:
                (response, self.confirm_clean) =\
                self.check_user(_("Are you sure you want to clean"))
                if not response:
                    return

        self.set_cursor(self.WATCH)
        if self.mode == self.mode_rs:
            if not self.chkTabs.get_active():
                indents="''"
            if not self.chkWhitespace.get_active():
                eol="''"
            else:
                eol="--eol"
            command=liblocation+"/fslint/supprt/rmlint/fix_ws.sh "+\
                    eol+" "+\
                    indents+" "+\
                    str(int(self.spinTabs.get_value()))
        elif self.mode == self.mode_ns:
            command="strip"

        clist = self.clists[self.mode]
        paths_to_clean = clist.selection

        numCleaned = 0
        totalSaved = 0
        row_data=clist.get_data("row_data")
        for row in paths_to_clean:
            path_to_clean = row_data[row][:-1] #strip '\n'
            try:
                startlen = os.stat(path_to_clean).st_size
            except OSError:
                self.ShowErrors(str(sys.exc_info()[1])+'\n')
                continue

            path_param = pipes.quote(path_to_clean)
            cleanProcess = subProcess(command + " " + path_param)
            cleanProcess.read()
            errors = cleanProcess.errdata
            del(cleanProcess)
            if len(errors):
                self.ShowErrors(errors)
            else:
                clist.set_background(row, self.bg_colour)
                clist.unselect_row(row,0)
                totalSaved += startlen - os.stat(path_to_clean).st_size
                numCleaned += 1
        status =  str(numCleaned) + _(" items cleaned (") + \
                  human_num(totalSaved,1000).strip() + 'B' + _(" saved)")
        self.status.set_text(status)
        self.set_cursor(None)

FSlint=fslint(liblocation+"/fslint.glade", "fslint")

gtk.main ()
